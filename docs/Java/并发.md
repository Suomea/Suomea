为什么需要并发，用来解决什么问题？  

- 提高资源的利用率，在某些情况下线程必须等待磁盘或者网络的 I/O 而阻塞，此时 CPU 空闲的时间片就可以运行另一个线程，提高资源的利用率。
- 公平性，多个用户和程序共享计算机资源，而不是一个程序一直运行，然后再启动下一个程序。
- 现代的 CPU 往往具有多个核心，天然具备并行运算的能力。多线程能够充分发挥处理器的强大能力。

并发带来的主要挑战是什么？

- 原子性，我们希望一些列指令能够原子地执行，在并发情况下，由于 CPU 调度带来了不确定性。
- 可视性，由于 CPU 的缓存和 Java 的内存模型，导致一个线程对共享变量的修改另一个线程不一定能过够及时看到。
- 有序性，在执行程序时，为了提高性能，编译器和处理器可能会对指令做重排序。


**原子操作** 是不能被线程调度机制中断的操作，一旦操作开始，那么它一定可以在可能发生的上下文切换之前执行完毕。
## 线程的状态

- `New` 新建的线程还没有开始执行。
- `Runnable` 可运行，已经在运行或者可以运行但是还没有获得 CPU 时间。
- `Blocked` 阻塞，在等待锁。
- `Waiting` 等待，Object.wait、Thread.join 不指定时间、 LockSupport.park 不指定时间，都会让线程处于该状态。该状态该在等待另一个线程的特定行为，比如 Object.notify/notifyAll、另一个线程结束、另一个线程 unpark 调用。 条件变量和信号量也会让线程处于该状态。
- `Timed waiting` 计时等待，指定指定的时间，Thread.sleep、Thread.join 指定时间、LockSupport.park 指定时间。
- `Terminated` 终止，线程执行完毕。

获取线程状态示例代码：
```c
    static volatile int done = 0;

    public static void main(String[] args) {
        Thread b = new Thread("B") {
            @Override
            public void run() {
                Thread currentThread = Thread.currentThread();
                System.out.println("hello, i'm " + currentThread.getName() 
					                + ", and my state is " + currentThread.getState());
                done = 1;
            }
        };

        System.out.println("B start before state is " + b.getState());
        b.start();
        while (done == 0)
            ;
        System.out.println("B start after state is " + b.getState());
    }
```

运行输出：
```
B start before state is NEW
hello, i'm B. And my state is RUNNABLE
B start after state is TERMINATED
```

## 线程中断
`Thread.interrupt()` 是一个明确的指示，告诉线程应该停止当前所做的事情。要使中断机制正常工作，线程本身必须要支持中断，换句话说要由程序员决定如何响应中断。

如果线程调用的方法需要捕获处理 `InteruptedException`，如下面代码，那么当线程阻塞在 `sleep()` 方法上时，此时对线程调用 `interrupt()` 方法，线程将立刻从 `sleep()` 阻塞返回并捕获 `InteruptedException`（或者任何要求抛出 `InterruptedException` 的调用）。
```java
for (int i = 0; i < importantInfo.length; i++) {
    // Pause for 4 seconds
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {
        // We've been interrupted: no more messages.
        return;
    }
    // Print a message
    System.out.println(importantInfo[i]);
}
```


如果线程没有调用抛出 `InterruptedException` 的方法，那么如果想要使中断机制正常工作，就要在代码中不断调用 `Thread.interrupted()` 检查是否已收到中断：
```java
for (int i = 0; i < inputs.length; i++) {
    heavyCrunch(inputs[i]);
    if (Thread.interrupted()) {
        // We've been interrupted: no more crunching.
        return;
    }
}
```
更复杂业务的情况下，最好是检测到中断后抛出 `InterruptedException`，这样可以在外部的调用将处理中断的代码放在一个 `catch` 子句中。

中断机制是使用内部 `interrupted` 标志来实现的，通过 interrupt() 方法将设置该标志。当线程内部使用静态方法 `Thread.interrupted()` 方法检查中断时，会获取中断状态然后会清除中断状态。而线程通过 `isInterrupted()` 方法查询另一个线程的中断状态时，不会更改中断状态。
```java
	// Thread 的成员变量
	volatile boolean interrupted;
```

通过 `InterruptedException` 如 `sleep()` 方法，在捕获该异常后线程的中断状态将自动清除。但是另一个线程可以继续设置中断。

如果线程阻塞在锁或者 I/O 等待时，也不会对 `interrupt()` 中断进行响应。

当然 Java 也提供了 `ReentrantLock` 阻塞可以被中断的能力，通过 `lockIntettuptibly()` 方法获取锁，该方法要求抛出 `InterruptedException` 异常。



## 使用线程的方法

- 实现 Runnable 接口。
- 实现 Callable 接口。
- 继承 Thread 类。

实现 Runnable 和 Callable 接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，因为最后还需要通过 Thread 来启动线程执行任务。

通过继承 Thread 调用 start() 方法来启动线程：
```java
    static volatile int done = 0;

    public static void main(String[] args) {
        System.out.println("main thread start!");

        new Thread("B") {
            @Override
            public void run() {
                System.out.println("hello, i'm " + Thread.currentThread().getName());
                done = 1;
            }
        }.start();

        while (done == 0)
            ;
        System.out.println("main thread end!");
    }
```

实现 Runnable 接口：
```java
    static volatile int done = 0;  
  
    public static void main(String[] args) {  
        System.out.println("main thread start!");  
  
        new Thread(new Runnable() {  
            @Override  
            public void run() {  
                System.out.println("hello, i'm " + Thread.currentThread().getName());  
                done = 1;  
            }  
        }, "B").start();  
        while (done == 0)  
            ;  
        System.out.println("main thread end!");  
    }  
```

实现 Callable 接口：
```c
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main thread start!");

        FutureTask<String> futureTask = new FutureTask<>(new Callable<String>() {
            @Override
            public String call() throws Exception {
                return "hello, i'm B";
            }
        });
        Thread thread = new Thread(futureTask);
        thread.start();
        System.out.println(futureTask.get());
        System.out.println("main thread end!");
    }
```


## volatile 
`volatile` 可以说是 JVM 提供的轻量级线程同步机制。如果将一个域声明为 `volatile` 的，那么只要对这个域产生了写操作，那么所有后续的读操作都可以看到这个修改，即使使用了本地缓存。换句话说，`volatile` 保证可视性。

原子操作可以应用于除 `long` 和 `double` 之外的所有基本类型之上的“简单操作”。对于读和写入除 `long` 和 `double` 之外的基本类型变量的操作，可以保证它们是原子的。但是 JVM 对于 64 位的 `long` 和 `double` 的读取和写入当作两个分离的 32 位操作来执行，如果发生了上下文切换，可能会导致错误（称为字撕裂）。当定义 `long` 和 `double` 变量时，如果使用 `volatile` 关键字，读和写就会获得原子性保证。

`volatile` 还有一个语义是禁止指令重排序优化。先看下面的 `Double Check Lock` 单例实现代码：
```java
public class Singleton {  
    private volatile static Singleton INSTANCE = null;  
    public static Singleton instance() {  
        if(INSTANCE == null) {  
            synchronized (Singleton.class) {  
                if(INSTANCE == null) {  
                    INSTANCE = new Singleton();  
                }  
            }  
        }  
        return INSTANCE;  
    }  
}
```

语句 `INSTANCE = new Singleton();` 会包含至少三步操作：

1. 给 `Singleton` 的实例分配内存。
2. 调用 `Singleton()` 的构造函数，初始化成员变量。
3. 将 `INSTANCE` 指向分配的内存空间，此时 `INSTANCE` 就不是 `null` 了。

如果 `INSTANCE` 不使用 `volatile` 修饰，就有可能发生指令重排序，那么步骤 2 和 3 的顺序就有可能颠倒。如果这种情况下，切换线程，新的线程判断 `INSTANCE` 不为空，不需要获取锁就拿到未初始化完成的对象了，使用 `volatile` 就能避免这种问题。
## synchronized 同步

关键字 synchronized 可以保证在同一时刻，只有一个线程可以执行某一个方法或者某一个代码块。当一个对象被一个线程修改的时候，它能够阻止另一个线程观察到对象内部不一致的状态，并且还可以保证进入同步方法或者代码块的每个线程都能看到由同一个锁保护的之前所有的修改结果。

synchronized 锁是非公平的，可重入的。

synchronized 代码块经过编译之后，会在同步块的前后分别形成 [monitorenter](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.monitorenter) 和 [monitorexit](https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html#jvms-6.5.monitorexit) 这两个字节码指令。

源码：
```java
    public int add(int a, int b) {
        synchronized(this) {
            return a + b;
        }
    }
```

获取字节码 `javap -c class_file`：
```
	   // ...
       3: monitorenter
       4: iload_1
       5: iload_2
       6: iadd
       7: aload_3
       8: monitorexit
       9: ireturn
      10: astore        4
      12: aload_3
      13: monitorexit
      // ...
```

monitorenter 和 monitorexit 这两个字节码指令都需要一个 reference 类型的参数来指定要锁定和解锁的对象，注意，是引用类型不能是基本类型。如果没有明确指定，那么就根据 synchronized 修饰的是实例方法还是静态方法，去取对应的对象的实例或者 Class 对象来作为锁对象。

每个对象都与一个监视器（可以理解为锁）关联，当监视器具有所有者时，监视器就是被锁定的。

执行 monitorenter 的线程会尝试将自己设置为 reference 对象监视器的所有者（ownership）：
- 如果监视器的 entry count 为 0，则线程将进入监视器并将 entry count 设置为 1。这样线程就是监视器的所有者。
- 如果线程已是监视器的所有者，它将重新进入监视器，并增加 entry count。
- 如果另一个线程已经拥有监视器，则该线程将阻塞，直到监视器的 entry count 为 0，然后再次尝试获取监视器的所有权。

执行 monitorexit 的线程必须是监视器的所有者，否则会抛出 `IllegalMonitorStateException` 异常。该操作会减少监视器的 entry count，如果减少到 0 则退出监视器。此时，其它线程可以尝试锁定监视器。

synchronized 语法的使用方式：
```java
    void incrAmount(int amount) {
        synchronized (this) {
            ...
        }
    }

	synchronized void incrAmount(int amount) {  
		...
	}

    void incrAmount(int amount) {
        synchronized (App.class) {
            ...
        }
    }

	synchronized static void incrAmount(int amount) {  
        ...  
	}
```


## Lock 同步
ReentranLock 的作用和 synchronized 很相似，它们都具备可重入的特性。但是它们有如下区别：
- 一个区别是 RenntranLock 为 API 层面的互斥锁，需要 lock() 和 unlock() 配合 try/finally 语块来完成，而 synchronized 则是语法层面的。
- 另一个区别是，ReentranLock 具备一些高级功能：锁定可中断 lockIntettuptibly()、可是设置等待时间、可实现公平锁，以及锁可以绑定多个条件。

ReentrantLock 实现了 Lock 接口：
```java
public interface Lock {  
	void lock();  
	void lockInterruptibly() throws InterruptedException;  
	
	boolean tryLock();  
	boolean tryLock(long time, TimeUnit unit) throws InterruptedException;  
	
	void unlock(); 
	
	Condition newCondition();  
}
```


## 死锁
一般两种方式来避免死锁：
- 避免获取锁的顺序不一致。
- 使用 tryLock 方法来获取锁。