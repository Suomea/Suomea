为什么需要并发，用来解决什么问题？  

- 提高资源的利用率，在某些情况下线程必须等待磁盘或者网络的 I/O 而阻塞，此时 CPU 空闲的时间片就可以运行另一个线程，提高资源的利用率。
- 公平性，多个用户和程序共享计算机资源，而不是一个程序一直运行，然后再启动下一个程序。
- 现代的 CPU 往往具有多个核心，天然具备并行运算的能力。多线程能够充分发挥处理器的强大能力。

并发带来的主要挑战是什么？

- 原子性，我们希望一些列指令能够原子地执行，在并发情况下，由于 CPU 调度带来了不确定性。
- 可视性，由于 CPU 的缓存和 Java 的内存模型，导致一个线程对共享变量的修改另一个线程不一定能过够及时看到。
- 有序性，在执行程序时，为了提高性能，编译器和处理器可能会对指令做重排序。

## 线程的状态

- New 新建的线程还没有开始执行。
- Runnable 可运行，已经在运行或者可以运行但是还没有获得 CPU 时间。
- Blocked 阻塞，在等待锁。
- Waiting 等待，Object.wait、Thread.join 不指定时间、 LockSupport.park 不指定时间，都会让线程处于该状态。该状态该在等待另一个线程的特定行为，比如 Object.notify/notifyAll、另一个线程结束、另一个线程 unpark 调用。 条件变量和信号量也会让线程处于该状态。
- Timed waiting 计时等待，指定指定的时间，Thread.sleep、Thread.join 指定时间、LockSupport.park 指定时间。
- Terminated 终止，线程执行完毕。

获取线程状态示例代码：
```c
    static volatile int done = 0;

    public static void main(String[] args) {
        Thread b = new Thread("B") {
            @Override
            public void run() {
                Thread currentThread = Thread.currentThread();
                System.out.println("hello, i'm " + currentThread.getName() 
					                + ". And my state is " + currentThread.getState());
                done = 1;
            }
        };

        System.out.println("B start before state is " + b.getState());
        b.start();
        while (done == 0)
            ;
        System.out.println("B start after state is " + b.getState());
    }
```

运行输出：
```
B start before state is NEW
hello, i'm B. And my state is RUNNABLE
B start after state is TERMINATED
```

## 线程中断
`Thread.interrupt()` 是一个明确的指示，告诉线程应该停止当前所做的事情。要使中断机制正常工作，线程本身必须要支持中断，换句话说要由程序员决定如何响应中断。

如果线程调用的方法需要捕获处理 `InteruptedException`，如下面代码。那么当线程阻塞在 `sleep()` 方法上时，此时对线程调用 `interrupt()` 方法，线程将立刻从 `sleep()` 阻塞返回并捕获 `InteruptedException`（或者任何要求抛出 `InterruptedException` 的调用）。
```java
for (int i = 0; i < importantInfo.length; i++) {
    // Pause for 4 seconds
    try {
        Thread.sleep(4000);
    } catch (InterruptedException e) {
        // We've been interrupted: no more messages.
        return;
    }
    // Print a message
    System.out.println(importantInfo[i]);
}
```


如果线程没有调用抛出 `InterruptedException` 的方法，那么如果想要使中断机制正常工作，就要在代码中不断调用 `Thread.interrupted()` 检查是否已收到中断：
```java
for (int i = 0; i < inputs.length; i++) {
    heavyCrunch(inputs[i]);
    if (Thread.interrupted()) {
        // We've been interrupted: no more crunching.
        return;
    }
}
```
更复杂的情况下，最好是检测到中断抛出 InterruptedException，这样可以在外部的调用将处理中断的代码放在一个 catch 子句中。

中断机制是使用内部 `interrupted` 标志来实现的，通过 interrupt() 方法将设置该标志。当线程内部使用静态方法 `Thread.interrupted()` 方法检查中断时，会获取中断状态然后会清除中断状态。而线程通过 `isInterrupted()` 方法查询另一个线程的中断状态时，不会更改中断状态。
```java
	// Thread 的成员变量
	volatile boolean interrupted;
```

通过 `InterruptedException` 如 `sleep()` 方法，在捕获该异常后线程的中断状态将自动清除。但是另一个线程可以继续设置中断。

如果线程阻塞在锁或者 I/O 等待时，也不会对 `interrupt()` 中断进行响应。

当然 Java 也提供了 `ReentrantLock` 阻塞可以被中断的能力，通过 `lockIntettuptibly()` 方法获取锁，该方法要求抛出 `InterruptedException` 异常。



## 使用线程的方法

- 实现 Runnable 接口。
- 实现 Callable 接口。
- 继承 Thread 类。

实现 Runnable 和 Callable 接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，因为最后还需要通过 Thread 来启动线程执行任务。

通过继承 Thread 调用 start() 方法来启动线程：
```java
    static volatile int done = 0;

    public static void main(String[] args) {
        System.out.println("main thread start!");

        new Thread("B") {
            @Override
            public void run() {
                System.out.println("hello, i'm " + Thread.currentThread().getName());
                done = 1;
            }
        }.start();

        while (done == 0)
            ;
        System.out.println("main thread end!");
    }
```

实现 Runnable 接口：
```java
    static volatile int done = 0;  
  
    public static void main(String[] args) {  
        System.out.println("main thread start!");  
  
        new Thread(new Runnable() {  
            @Override  
            public void run() {  
                System.out.println("hello, i'm " + Thread.currentThread().getName());  
                done = 1;  
            }  
        }, "B").start();  
        while (done == 0)  
            ;  
        System.out.println("main thread end!");  
    }  
```

实现 Callable 接口：
```c
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main thread start!");

        FutureTask<String> futureTask = new FutureTask<>(new Callable<String>() {
            @Override
            public String call() throws Exception {
                return "hello, i'm B";
            }
        });
        Thread thread = new Thread(futureTask);
        thread.start();
        System.out.println(futureTask.get());
        System.out.println("main thread end!");
    }
```

## synchronized 同步
同步代码块，在调用对象上的锁。
```java
    void incrAmount(int amount) {
        synchronized (this) {
            ...
        }
    }
```

同步一个方法，在调用对象上的锁。
```java
	synchronized void incrAmount(int amount) {  
		...
	}
```

同步一个类，在 App 类对象上的锁。
```java
    void incrAmount(int amount) {
        synchronized (App.class) {
            ...
        }
    }
```

同步静态方法，在方所所在的类对象上的锁。
```java
	synchronized static void incrAmount(int amount) {  
        ...  
	}
```


## Lock 同步