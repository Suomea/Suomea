为什么需要并发，用来解决什么问题？  

- 提高资源的利用率，在某些情况下线程必须等待磁盘或者网络的 I/O 而阻塞，此时 CPU 空闲的时间片就可以运行另一个线程，提高资源的利用率。
- 公平性，多个用户和程序共享计算机资源，而不是一个程序一直运行，然后再启动下一个程序。
- 现代的 CPU 往往具有多个核心，天然具备并行运算的能力。多线程能够充分发挥处理器的强大能力。

并发带来的主要挑战是什么？

- 原子性，我们希望一些列指令能够原子地执行，在并发情况下，由于 CPU 调度带来了不确定性。
- 可视性，由于 CPU 的缓存和 Java 的内存模型，导致一个线程对共享变量的修改另一个线程不一定能过够及时看到。
- 有序性，在执行程序时，为了提高性能，编译器和处理器可能会对指令做重排序。

线程的状态：

- New 新建的线程还没有开始执行。
- Runnable 可运行，已经在运行或者可以运行但是还没有获得 CPU 时间。
- Blocked 阻塞，在等待锁。
- Waiting 等待，Object.wait、Thread.join 不指定时间、 LockSupport.park 不指定时间，都会让线程处于该状态。该状态该在等待另一个线程的特定行为，比如 Object.notify/notifyAll、另一个线程结束、另一个线程 unpark 调用。 条件变量和信号量也会让线程处于该状态。
- Timed waiting 计时等待，指定指定的时间，Thread.sleep、Thread.join 指定时间、LockSupport.park 指定时间。
- Terminated 终止，线程执行完毕。

获取线程状态示例代码：
```c
    static volatile int done = 0;

    public static void main(String[] args) {
        Thread b = new Thread("B") {
            @Override
            public void run() {
                Thread currentThread = Thread.currentThread();
                System.out.println("hello, i'm " + currentThread.getName() 
					                + ". And my state is " + currentThread.getState());
                done = 1;
            }
        };

        System.out.println("B start before state is " + b.getState());
        b.start();
        while (done == 0)
            ;
        System.out.println("B start after state is " + b.getState());
    }
```

运行输出：
```
B start before state is NEW
hello, i'm B. And my state is RUNNABLE
B start after state is TERMINATED
```

线程中断：


有三种使用线程的方法：

- 实现 Runnable 接口。
- 实现 Callable 接口。
- 继承 Thread 类。

实现 Runnable 和 Callable 接口的类只能当作一个可以在线程中运行的任务，不是真正意义上的线程，因为最后还需要通过 Thread 来启动线程执行任务。

通过继承 Thread 调用 start() 方法来启动线程：
```java
    static volatile int done = 0;

    public static void main(String[] args) {
        System.out.println("main thread start!");

        new Thread("B") {
            @Override
            public void run() {
                System.out.println("hello, i'm " + Thread.currentThread().getName());
                done = 1;
            }
        }.start();

        while (done == 0)
            ;
        System.out.println("main thread end!");
    }
```

实现 Runnable 接口：
```java
    static volatile int done = 0;  
  
    public static void main(String[] args) {  
        System.out.println("main thread start!");  
  
        new Thread(new Runnable() {  
            @Override  
            public void run() {  
                System.out.println("hello, i'm " + Thread.currentThread().getName());  
                done = 1;  
            }  
        }, "B").start();  
        while (done == 0)  
            ;  
        System.out.println("main thread end!");  
    }  
```

实现 Callable 接口：
```c
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println("main thread start!");

        FutureTask<String> futureTask = new FutureTask<>(new Callable<String>() {
            @Override
            public String call() throws Exception {
                return "hello, i'm B";
            }
        });
        Thread thread = new Thread(futureTask);
        thread.start();
        System.out.println(futureTask.get());
        System.out.println("main thread end!");
    }
```

Synchronized 同步
同步代码块，在调用对象上的锁。
```java
    void incrAmount(int amount) {
        synchronized (this) {
            ...
        }
    }
```

同步一个方法，在调用对象上的锁。
```java
	synchronized void incrAmount(int amount) {  
		...
	}
```

同步一个类，在 App 类对象上的锁。
```java
    void incrAmount(int amount) {
        synchronized (App.class) {
            ...
        }
    }
```

同步静态方法，在方所所在的类对象上的锁。
```java
	synchronized static void incrAmount(int amount) {  
        ...  
	}
```


