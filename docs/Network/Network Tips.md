## 校验和

为甚正常情况下计算出的校验和的值永远不会全是 1？

为什么校验和的计算要用反码，求和之后再取反码？

## 为什么 TCP 和 UDP 的校验和计算时要增加伪首部部分


## TCP 的缓存和窗口的关系

有 4 和缓存，客户端的发送和接收缓存，服务器的发送和接收缓存。需要注意的时它们都是和 Scoket 一一对应的，并不是操作系统全局唯一的。

## 全双工、半双工和单工

**全双工 Full Duplex**，是指在同一时间，数据可以同时双向传输，即通信的两个端点可以同时发送和接收数据而不会发生碰撞。

**半双工 Half Duplex**，是指在同一时间，数据只能在一个方向上传输。虽然通信的两个端点都可以发送和接收数据，但不能同时进行。例如，对讲机和无线电通信就是半双工。

**单工 Simplex**，是指数据只能在一个方向上传输，并且只能由一个设备发送数据，另一个设备只能接收数据。

## TCP 能不能传输超过 4GB 的数据

肯定是可以的。

首先虽然 TCP 的序号为 32 位，但是序号的主要目的表示字节的顺序，其次才是标识唯一一个字节，序号的值在达到最大值之后将回到 0。

如果接收方的缓存大于 4GB，那么发送端不就无法弄明白接收方的确认是针对哪一个字节的了吗？接收方的缓存大小即窗口大小，而窗口大小字段是 16 位的，不会超过 65535 字节。所以问题不存在。（当然，64KB 的窗口大小对于现在计算机来说太小了，因此 TCP 引入了 TCP 窗口缩放选项作为窗口缩放的比例因子，来扩大窗口的大小。）

## TCP 纯的 ACK 报文段不消耗序号

TCP 中的纯 ACK 报文段不消耗序号。

在 TCP 协议中，ACK 报文段用于确认已经成功接收到的数据。当接收方收到数据后，会发送一个 ACK 报文段给发送方，以确认接收到的数据。这个 ACK 报文段通常不包含任何数据，只有一个确认号字段，用来指示下一个期望接收的数据的序号。

因此，纯 ACK 报文段不携带数据，也不消耗序号，它们只是用来进行流量控制和确认数据接收

—— AI