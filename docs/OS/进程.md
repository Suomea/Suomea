## 进程的介绍
进程的非正式定义：进程就是正在运行的程序。  

进程的正式定义如下 ，引自 `IEEE Std 1003.1™-2017`。
> An address space with one or more threads executing within that address space, and the required system resources for those threads. 
> 在地址空间中执行的一个或多个线程，以及这些线程所需的系统资源。 
>   
> **Note:**
> Many of the system resources defined by POSIX.1-2017 are shared among all of the threads within a process. These include the process ID, the parent process ID, process group ID, session membership, real, effective, and saved set-user-ID, real, effective, and saved set-group-ID, supplementary group IDs, current working directory, root directory, file mode creation mask, and file descriptors.    
> POSIX.1-2017 定义的许多系统资源是在进程内的线程之间共享的。这些资源包括进程ID，进程组ID，...，当前工作目录，root 目录，文件创建预设权限和文件描述符。

了解进程的机器状态 `machine state` 可以更好的理解进程的构成，程序在运行时可以读取或更新的内容。

进程的机器状态有一个明显的组成部分，内存。指令，正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间，adress space）是进程的一部分。

进程的机器状态的另一部分是寄存器。许多指令明确地读取或更新寄存器，因此寄存器对于进程的执行很重要。

最后，程序也经常访问持久存储设备。

## 进程的创建
程序一般存储在磁盘中，操作系统运行进程的第一件事就是将代码和所有静态数据（例如初始化变量）加载（load）到内存中，加载到地址空间中。

将代码和静态数据加载到内存之后，操作系统在运行此进程之前还需要执行一些其它操作。必须为程序的运行时栈分配一些内存。C 程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。

操作系统也可能为程序的堆分配一些内存。

操作系统还将执行一些其它初始化任务，特别是与 I/O 相关的任务。例如，在 UNIX 系统中，默认情况下每个进程都打开 3 个文件描述符（file descriptor），用于标准输入、输出和错误。

通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与 I/O 设置相关的其它工作，操作系统为进程运行做好了准备。最后一项任务是启动程序，在入口处运行，即 `main()`。

## 进程的状态
在早期的计算机系统中，进程可能处于以下 3 种状态之一：

- **运行 running：** 在运行状态下，进程正在处理器上运行。发起 I/O 进入阻塞状态，取消调度进入就绪状态。

- **就绪 ready：** 在就绪状态下，进程已准备好运行，但是由于某种原因，系统选择不在此时运行。调度获得 CPU 时间进入运行状态。

- **阻塞 blocked：** 在阻塞状态下，一个进程执行了某种操作进入阻塞，直到发生其它事件时才会准备运行。I/O 完成进入就绪状态。

## 进程的数据结构
操作系统有一些关键的数据结构来跟踪各种相关的信息，例如，为了跟踪每个进程的状态，操作系统可能会为所有就绪的进程保留某种进程列表（process list），以及跟踪当前正在运行的进程的一些附加信息。操作系统还必须以某种方式跟踪被阻塞的进程，当 I/O 事件完成时，操作系统应确保唤醒正确的进程，让它准本好再次运行。

对于停止的进程，寄存器上下文将保存其寄存器的内容。通过恢复这些寄存器，将它们的值回放实际物理寄存器种，操作系统可以恢复运行该进程。
```c
// the registers xv6 will save and restore
// to stop and subsequently restart a process
strct context {
	int eip;
	int esp;
	int ebx;
	int ecx;
	int esi;
	int edi;
	int ebp;
}
```


除了运行、就绪和阻塞之外，还有其它一些进程可以处于的状态。
```c
// the different states a process can be in
enum proc_state { UNUSED, EMBROY, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
```

进程的数据结构。
```c
// the information xv6 tracks about each process
// including its register context and state
struct proc {
	char *mem;                // start of process memory
	uint sz;                  // size of process memory
	char *kstack;             // bottom of kernel stack for this process
	enum proc_state state;    // process state
	int pid;                  // process ID
	struct proc *parent;      // parent process
	void *chan;               // if non-zero, sleeping on chan
	int killed;               // if non-zero, have been killed
	struct file *ofile[NOFILE];    // open file
	struct inode *cwd;        // current directory
	struct context context;   // switch here to run process
	struct trapframe *tf;     // current interrupt
}
```

## 进程的 API
所有现代操作系统都以某种形式提供这些 API。

- 创建（create）：操作系统必须包含一些创建新进程的方法。

- 销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进程的接口。

- 等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。

- 其它控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其它控制。例如，大多数操作系统提供某种方法来暂停进程，然后恢复。

- 状态（status）：通常也有一些接口可以获取有关进程的状态信息，例如运行了多长时间，或者处于什么状态。

### `fork()` 系统调用


### `wait()` 系统调用

### `exec()` 系统调用

进程间通信