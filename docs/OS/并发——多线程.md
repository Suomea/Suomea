### 什么是线程
经典的观点是一个程序只有一个执行点（一个程序计数器，用来存放要执行的指令），但是多线程（multi-threaded）程序会有多个执行点（多个程序计数器，
每个都用于取指令和执行）。换一个角度看，每个线程都类似与独立的进程，只有一点区别：它们共享地址空间，从而能够访问相同的数据。

线程有自己的程序计数器，记录程序从哪里获取指令。每个线程有自己的一组用于计算的寄存器。如果有两个线程运行在一个处理器上，从一个线程（T1）切换到另一个线程（T1）时
必定发生上下文切换（context switch）。线程的上下文切换需要保存一个或多个线程控制块（Thread Control Block，TCB），从而保存每个线程的状态。但是与进程的上下文切换相比，
线程的上下文切换地址空间不变（即不需要切换当前使用的页表）。

当在进程中创建一个新的线程时，新的线程拥有自己的栈（因此也有自己的局部变量）、程序计数器（PC），但与它的创建者共享全局变量、文件描述符、信号处理函数和当前目录状态。
在单线程（进程）的地址空间模型中（左），只有一个栈，通常位于地址空间的底部。然而在多线程的进程中，每个线程都有一个栈，地址空间看起来会有不同（右）。
![](../pictures/并发——多线程-1.png)
多个线程破坏了地址空间布局的美感，之前堆和栈可以互不影响地增长知道地址空间耗尽。多个栈就没这个简单了，不过通常栈不会很大（除了大量使用递归的程序）。

### 线程的优点和缺点

#### 优点
1. 一般而言线程之间的切换需要操作系统做的事情比进程间的切换少的多，因此多个线程对资源的需求要远小于多进程。

#### 缺点
1. 编写多线程的程序需要非常仔细。
2. 对多线程程序的调试要比对单线程程序的调试困难的多。
3. 有些时候更多的线程并不一定运行的更快（线程数一般应小于等于操作系统支持的并行线程数，因为过多的线程上下文切换所带来的损耗也会增加）。

### 线程的 API

#### 创建线程
```c
#include <pthread.h>

int pthread_create(pthread_t *thread, pthread_attr *attr, void *(*start_routine) (void *), void *arg);
```
第一个参数指向 pthread_t 类型数据的指针，线程被创建时，这个指针指向的变量中将被写入一个标识符，我们用该标识符来引用新线程。

第二个参数用于设置线程的属性，一般不需要特殊的属性，设置为 NULL 即可。

最后两个参数分别告诉线程将要启动执行的函数和传递给该函数的参数。

该函数调用成功将返回 0，失败将返回错误代码。

#### 终止线程
线程通过调用 pthread_exit 函数终止执行。这个函数的作用是，终止调用它的线程并返回一个指向某个对象的指针。

!!! warning "retval 绝不能赋值为指向局部变量的指针，因为线程调用该函数后，这个局部变量就不存在了，这将引起严重的程序漏洞。"
```c
#include <pthread.h>

void pthread_exit(void *retval);
```

#### 等待线程
pthread_join 将阻塞调用该函数的线程直到等待的目标线程运行完成。
```c
#include <stdio.h>

int pthread_join(pthread_t th, void **thread_return);
```
第一个参数指定了将要等待的线程。

第二个参数是一个指针，它指向另一个指针，而后者指向线程的返回值。

该函数成功调用将返回 0，失败时返回错误代码。

#### 代码示例
```c
// main.c
// 编译：gcc main.c -pthread -o main
// 运行：./main
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <string.h>

void *thread_function(void *arg);

char message[] = "Hello world!";

int main() {
    int res;
    pthread_t a_thread;
    void *thread_result;

    res = pthread_create(&a_thread, NULL, thread_function, (void *) message);
    if(res != 0) {
        perror("Thread create failed!");
        exit(EXIT_FAILURE);
    }

    printf("Waiting for thread to finish...\n");
    res = pthread_join(a_thread, &thread_result);
    if(res != 0) {
        perror("Thread join failed!");
        exit(EXIT_FAILURE);
    }

    printf("Thread joined, it returned %s\n", (char *) thread_result);
    printf("Message is now %s\n", message);
    exit(EXIT_SUCCESS);
}

void *thread_function(void *arg) {
    printf("thread function is running. Argument was %s\n", (char *) arg);
    sleep(3);
    strcpy(message, "Bye!");
    pthread_exit("Thank you for CPU tune!");
}
```

### 多线程的带来的挑战
1. 不可控的线程调度。
1. 错误的共享数据——原子性的愿望。
2. 等待一个条件满足。

### 并发原语



### QA
1. Java 中线程栈空间默认的限制是多少？通过什么参数进行调节？

2. 为什么 pthread_join 第二个参数被定义为一个指向指针的指针？  

    有两个原因导致 pthread_join 的第二个参数被定义为一个只想指针的指针。  
    - 第一个原因是这个指针指向我们希望另一个线程的返回值，因为另一个函数可以返回任何东西，所以它被定义为返回一个指向 void 的指针。  
    - 第二个原因是 pthread_join() 函数改变了传入参数的值，所以需要一个指向该值（指向 void 的指针）的指针。

    错误的实现方式在方法内部改变形参的指向并没有影响到实参。正确的实现方式是将参数定义为指针的指针，然后再将指向实参的指针传递给函数，最终将实参指向正确的结果。
    ```c
    void *thread_result = NULL;
   
    // 错误的实现方式
    res = pthread_join(a_thread, thread_result);
    int pthread_join(Thread thread, void *result) {
        a_type a = a_typet(); // 模拟另一个线程的返回结果
        result = &a; // 方法结束时 thread_result 没有获得想要的结果，并未指向 a
        // 最终的结果是 result 指针指向 a，thread_result 指针指向 NULL
    }
   
    // 正确的实现方式
    res = pthread_join(a_thread, &thread_result);
    int pthread_join(Thread thread, void **result) {
        a_type a = a_typet(); // 模拟另一个线程的返回结果
        *result = &a; // 方法结束时 thread_result 获得想要的结果，即指向 a
        // 最终的结果是 result 指针指向 thread_result 指针，thread_result 指针指向 a
    }
    ```