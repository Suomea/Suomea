---
comments: true
---

通过对多线程的介绍，我们看到了并发编程一个最基本的问题：我们希望原址性的执行一系列指令，但是由于单处理器的中断（或者多个线程在多个处理器上执行），我们做不到。
接下来我们介绍锁（lock），直接解决这一问题。在程序代码中加锁，放在临界区周围，保证临界区能够像单条原子指令一样执行。

### Pthread 锁
POSIX 库将锁称为互斥量（mutex），因为它被用来提供线程之间的互斥。即当一个线程在临界区，它能够阻止其它线程进入直到当前线程离开临界区。

```c
#include <pthread.h>

int pthread_mutex_init(pthread_mutex *mutex, const pthread_mutexattr_t *mutexattr);

int pthread_mutex_lock(pthread_mutex_t *mutex);

int pthread_mutex_unlock(pthread_mutex_t *mutex);

int pthread_mutex_destory(pthread_mutex_t *mutex);
```
### 如何实现锁
#### 简单的尝试
我们的想法很简单：用一个变量来标志锁是否被某些线程占用。

第一个线程进入临界区，调用 lock 函数，检查标志是否为 1（这里不是 1），然后设置标志为 1，
表示线程持有该锁。结束临界区时，线程调用 unlock 函数，清除标志，表示锁未被持有。

线程在等待已经被持有的锁时，采用了自旋等待的技术（spin waiting），就是不停的检查锁标志的值。
```c
struct lock_t {
    int flag;
} lock_t;

void init(struct lock_t *mutex) {
    mutex->flag = 0;
}

void lock(struct lock_t *mutex) {
    while (mutex->flag == 1)    // test the flag
        ;   // spain wait
    mutex->flag = 1;    // set the flag
}

void unlock(struct lock_t *mutex) {
    mutex->flag = 0;
}
```
遗憾的是这段代码有两个问题：正确性和性能。

有两种情况可能导致正确性的问题。
一种是不可控的线程调度，因为 lock 函数加锁的逻辑分为两步并且线程的调度不可控，可能会导致两个线程同时加锁成功。我们需要可靠的原子操作（guaranteed atomic operations）来解决这个问题。

| Thread 1 | Thread 2 |
| -- | -- |
| test the flag; // 中断：切换到 Thread 2 |  |
|  | test the flag; set the flag; // 中断：切换到 Thread 1 |
| set the flag; |  |

另一种是线程模型（或者 CPU 缓存模型）使得变量缓存在线程本地（或者 CPU 缓存），导致即使一个线程加锁成功而另一个线程观察不到仍能加锁成功。我们通过总线加锁（LOCK# 信号和 LOCK 指令前缀）来解决这个问题。

性能问题主要是自旋等待在等待其它线程释放锁的时候会浪费时间。尤其是在单处理器上，一个等待线程等待的目标线程甚至无法运行！

#### 硬件指令 test-and-set
尽管简单的尝试想法很好，但是没有硬件的支持是无法实现的。幸运的是，一些系统提供了这一指令，支持基于这种概念创建简单的锁。

在 x86 上，是 xchg（atomic change，原子交换）指令，该指令自动带有 LOCK 语义，通常称为测试并设置指令（test-and-set）。使用 C 代码来定义测试并设置指令做了什么。
```c
int TestAndSet(int *old_ptr, int new) {
    int old = *old_ptr;
    *old_ptr = new;
    return old;
}
```
#### 硬件指令 compare-and-swap

#### 硬件指令 fetch-and-add

### 如何解决过多的自旋

#### 线程让步

#### 休眠代替自旋

### QA
1. 如何实现可重入的锁？

2. 为什么汇编指令需要加上 LOCK 前缀？

3. 如何实现读写锁？

4. Java 通过锁能够实现互斥访问，但是执行完临界区的代码之后如何保证全局变量的可视性？

    如果一个线程解锁，那么紧跟着加锁的线程是能够看到上一个线程的改变的，由 Happen-before 规则约束。
    那么 Happen-before 底层又是如果实现的呢？https://gee.cs.oswego.edu/dl/jmm/cookbook.html

5. Java 对象头的结构是什么？在由无锁->轻量级锁->重量级锁过程中 CAS 的参数是什么？如何获取这些参数？