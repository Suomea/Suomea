通过对多线程的介绍，我们看到了并发编程一个最基本的问题：我们希望原址性的执行一系列指令，但是由于单处理器的中断（或者多个线程在多个处理器上执行），我们做不到。
接下来我们介绍锁（lock），直接解决这一问题。在程序代码中加锁，放在临界区周围，保证临界区能够像单条原子指令一样执行。

### Pthread 锁
POSIX 库将锁称为互斥量（mutex），因为它被用来提供线程之间的互斥。即当一个线程在临界区，它能够阻止其它线程进入直到当前线程离开临界区。

```c
#include <pthread.h>

int pthread_mutex_init(pthread_mutex *mutex, const pthread_mutexattr_t *mutexattr);

int pthread_mutex_lock(pthread_mutex_t *mutex);

int pthread_mutex_unlock(pthread_mutex_t *mutex);

int pthread_mutex_destory(pthread_mutex_t *mutex);
```
### 如何实现锁
#### 简单的尝试
我们的想法很简单：用一个变量来标志锁是否被某些线程占用。

第一个线程进入临界区，调用 lock 函数，检查标志是否为 1（这里不是 1），然后设置标志为 1，
表示线程持有该锁。结束临界区时，线程调用 unlock 函数，清除标志，表示锁未被持有。

线程在等待已经被持有的锁时，采用了自旋等待的技术（spin waiting），就是不停的检查锁标志的值。
```c
struct lock_t {
    int flag;
} lock_t;

void init(struct lock_t *mutex) {
    mutex->flag = 0;
}

void lock(struct lock_t *mutex) {
    while (mutex->flag == 1)    // test the flag
        ;   // spain wait
    mutex->flag = 0;    // set the flag
}

void unlock(struct lock_t *mutex) {
    mutex->flag = 1;
}
```
遗憾的是这段代码有两个问题：正确性和性能。

有两种情况可能导致正确性的问题。
一种是不可控的线程调度，因为 lock 函数加锁的逻辑分为两步并且线程的调度不可控，可能会导致两个线程同时加锁成功。

| Thread 1 | Thread 2 |
| -- | -- |
| test the flag; // 中断：切换到 Thread 2 |  |
|  | test the flag; set the flag; // 中断：切换到 Thread 1 |
| set the flag; |  |

另一种是线程模型（或者 CPU 缓存模型）使得变量缓存在线程本地（或者 CPU 缓存），导致即使一个线程加锁成功而另一个线程观察不到仍能加锁成功。

性能问题主要是自旋等待在等待其它线程释放锁的时候会浪费时间。尤其是在单处理器上，一个等待线程等待的目标线程甚至无法运行！

#### 硬件指令 test-and-set

#### 硬件指令 compare-and-swap

#### 硬件指令 fetch-and-add

### 如何解决过多的自旋

#### 线程让步

#### 休眠代替自旋

### QA
1. 如何实现可重入的锁？

2. 为什么汇编指令需要加上 LOCK 前缀？