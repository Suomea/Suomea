命题：

求解算数表达式，如果直接求算数表达式的值是相当困难的，因此分两步实现：  
1. 将算数表达式转换为另一种形式：后缀表达式。  
2. 计算后缀表达式的值。

## 后缀表达式求值
日常的表达式将操作符放在两个操作数中间，因为操作符在操作数的中间，因此称为中缀表达式。  

中缀表达式如：A+B\*C-D，其对应的后缀表达式为：ABC\*+D-。  
中缀表达式和后缀表达式的数字顺序是一样的均为: A->B->C->D。  

### 后缀表达式的求值逻辑  

- 由左向右逐个读取后缀表达式的元素。  
-- 如果读取的元素为操作数则将操作数压入栈中。  
-- 如果读取的元素为操作符，则取出栈顶的两个操作数，进行计算并将计算结果入栈。   

- 读取完毕，获取栈中元素即为计算结果。


### 求后缀表达式 ABC\*+D- 值
计算的后缀表达式为：ABC\*+D-，从后缀表达式中逐个读取元素。

1. 读取操作数 A 入栈。栈顶到栈底为 A。

2. 读取操作数 B 入栈。栈顶到栈底为 BA。

3. 读取操作数 C 入栈。栈顶到栈底为 CBA。  

4. 读取操作符 \*，取出栈顶的两个操作数 C 和 B，计算 B \* C 的值记为 Z，将 Z 压入栈中。栈顶到栈底为 ZA。  

5. 读取操作符 +，取出栈顶的两个操作数 Z 和 A，计算 A + Z 的值记为 Y，将 Y 压入栈中。栈顶到栈底为 Y。  

6. 读取操作数 D 入栈。栈顶到栈底为 DY。  

7. 读取操作符 -，取出栈顶的两个操作数 D 和 Y，计算 Y - D 的值记为 X，将 X 压入栈中。栈顶到栈底为 X。  

8. 读取完毕，弹出栈中的结果 X 即为计算结果：X->(Y - D)->(A + Z - D)->(A + B \* C - D)

## 将中缀表达式转换为后缀表达式

### 转换规则
- 由左向右逐个读取中缀表达式的元素。

- 如果元素为操作数，直接写至输出。

- 如果元素为左括号`(`，压入栈中。

- 如果元素为右括号`)`，若栈非空则重复以下步骤：  
--  取出栈顶元素。  
--  若取出元素不为`(`，则将取出元素写至输出；否则退出循环。
  
- 如果元素为操作符，记为 opThis。如果栈为空将 opThis 入栈；否则重复以下步骤直至栈为空，最后将 opThis 压入栈：  
  -- 取出栈顶元素记为 opTop。  
  -- 如果 opTop 为`(`，则重新将 opTop 入栈，退出循环。    
  -- 如果 opTop 为操作符，且 opTop 的优先级小于 opThis 的优先级，则重新将 opTop 入栈，退出循环。  
  -- 如果 opTop 为操作符，且 opTop 的优先级大于等于 opThis 的优先级，则将 opTop 写至输出，继续循环。

- 读取完毕，如果栈不为空，将栈中元素由栈顶至栈底逐个写入输出。

### 转换中缀表达式 A+B\*C-D
转换的中缀表达式为：A+B\*C-D，从中缀表达式中逐个读取元素。

1. 读取操作数 A，直接写至输出。输出为 A，栈为空。

2. 读取操作符 +，此时栈为空，将操作符 + 入栈。输出为 A，栈顶到栈底为 +。

3. 读取操作数 B，直接写至输出。输出为 AB，栈顶到栈底为 +。
 
4. 读取操作符 \*。  
   -- 取出栈顶元素为操作符 +，操作符 + 的优先级小于操作符 \*，则将操作 + 重新入栈。输出为 AB，栈顶到栈底为 +。
   -- 将操作符 \* 入栈。输出为 AB，栈顶到栈底为 \*+。

5. 读取操作数 C，直接写至输出。输出为 ABC，栈顶到栈底为 +。

6. 读取操作符 -。  
   -- 取出栈顶元素为操作符 *，操作符 * 的优先级大于操作符 -，则将操作符 \* 写至输出。输出为 ABC\*，栈顶到栈底为 +。  
   -- 取出栈顶元素为操作符 +，操作符 + 的优先级等于操作符 -，则将操作符 + 写至输出。输出为 ABC\*+，栈为空。  
   -- 将操作符 - 入栈。输出为 ABC\*+，栈顶到栈底为 -。

7. 读取操作数 D，直接写至输出。输出为 ABC\*+D，栈顶到栈底为 -。

8. 读取完毕，将栈中元素 - 写至输出。输出为 ABC\*+D-，完成中缀表达式到后缀表达式的转换。

## Java 代码实现

## C 代码实现
